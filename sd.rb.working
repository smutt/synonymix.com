#!/usr/bin/env ruby

############
# Requires #
############
require 'tree'
require 'cgi'

#############
# Constants #
#############
# Number of words to compare against before giving up
MaxCompare = 1200
# Let's be a little more secure than the default
# This is a builtin for Ruby
$SAFE = 2
# Set to true if running from CLI
CLI = false
# Our previously found distances
FN = "booty.txt"


###########
# Globals #
###########
# Array of words already added to the tree
# Stores string words not actual objects
# Necessary to prevent duplication
$added = Array.new
# Our traversal queue
$q = Array.new

###########
# Classes #
###########
class Word
  attr_reader :word, :syns
  
  def initialize(w)
    @word = clean(w)
    @syns = Array.new
    
    cmdBegin = "wn \'"
    cmdEnd = "\' -synsn|grep \"=>\"|sed s/=\\>//"
    cmd = cmdBegin << @word << cmdEnd
    rv = `#{cmd}`

    # Parse our response
    rv.each{ |x|
      if(! x.include?("INSTANCE OF")) # This indicates a proper noun
        y = x.strip.split(",")
        y.each{ |z|
          if(!z.include?("\'"))
            @syns.push(z.strip)
          end
        }
      end
    }
  end

  def clean(str)
    newStr = str.gsub(/[^a-z\s]/, '')
    newStr.untaint
    return newStr
  end
end

####################
# Lonely Functions #
####################
# Store our results for future posterity
# Takes a single results array of strings
# Be careful not to clobber res since Ruby is pass by reference
def storeResults(res)
  f = File.new(FN, "a+")

  line = String.new
  res.each{ |r|
    line +=  r + ":"
  }
  line.chop!
  
  f.puts(line)
  f.close
end

# Prints results
# Takes an array of results from 1st word to 2nd word
def printResults(res)
  if(CLI)
    print res.shift.to_s
    res.each{ |r|
      print "-->" + r.to_s
    }
    print "\nDistance = " + res.length.to_s + "\n"
  else
    puts $cgi.header
    
    htmlStart = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">"
    htmlStart << "\n </html>"
    htmlStart << "\n  <head>"
    htmlStart << "\n    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"/>"
    htmlStart << "\n    <title>Synonymic Distance Finder</title>"
    htmlStart << "\n    <link rel=\"stylesheet\" href=\"http://metafarce.com/textpattern/css.php?s=default\" type=\"text/css\" media=\"screen\" />"
    htmlStart << "\n  </head>"
    htmlStart << "\n  <body>"
    htmlStart << "\n    <center>"
    htmlStart << "\n      Please enter two nouns below to find their Synonymic distance"
    htmlStart << "\n      <form method=\"post\" action=\"sd.rb\">"
    htmlStart << "\n        <input name=\"w1\" type=\"text\"></input>-->"
    htmlStart << "\n        <input name=\"w2\" type=\"text\"></input>"
    htmlStart << "\n        <input type=\"submit\" value=\"Go!\"></input>"
    htmlStart << "\n      </form><br><br>"
    print htmlStart

    print "\n<br>" + res.shift.to_s
    res.each{ |r|
      print "-->" + r.to_s
    }
    print "\n<br>Distance = " + res.length.to_s

    htmlEnd = "\n    </center>"
    htmlEnd << "\n  </body>"
    htmlEnd << "\n</html>"
    print htmlEnd
  end
end

###################
# Begin Execution #
###################
# Were we invoked from CLI or CGI
if(CLI)
  $w1 = $*[0]
  $w2 = $*[1]
else
  $cgi = CGI.new
  $w1 = $cgi['w1'].strip
  $w2 = $cgi['w2'].strip
end

if($w1 == $w2)
  res = Array.new
  res.push($w1)
  printResults(res)
  exit
end

start = Word.new($w1)
if(start.syns.empty?)
  if(CLI)
    puts "No synonyms for " + $w1
    exit
  else
    # TODO: Handle this condition for CGI invocation
    exit
  end
end

if(start.syns.include?($w2))
  res = Array.new
  res.push($w1)
  res.push($w2)
  printResults(res)
  exit
end

# Check our previous searches before searching again
IO.foreach(FN){ |line|
  r = line.split(":")
  r[r.length - 1].strip! # Each line comes with a trailing CR
  if(r[0] == $w1 && r[r.length - 1] == $w2)
    printResults(r)
    exit
  end
} 

# Prime the tree for search
$rNode = Tree::TreeNode.new("ROOT", start)
$q.push($rNode)
start.syns.each{ |kid|
  if(! $added.include?(kid))
    $rNode << Tree::TreeNode.new(kid, Word.new(kid))
    $added.push(kid)
  end
}

# Perform a breadth first search using the FIFO queue $q
ii = 0
while ii < MaxCompare do
  # Shift a Node off of our FIFO and examine it for match
  # If no match than create child Nodes for its syns
  parent = $q.shift
  parent.children.each{ |kid|
    if(kid.content.syns.include?($w2)) # Have we found our word?
      $found = kid
      break
    else
      kid.content.syns.each{ |grandKid|
        if(! $added.include?(grandKid))
          gKidWord = Word.new(grandKid)
          if(gKidWord.syns.empty?) # Check if grandkid is a leaf-node before adding
            $added.push(grandKid)
          else
            kid << Tree::TreeNode.new(grandKid, gKidWord)
            $added.push(grandKid)
          end
        end
      }
      $q.push(kid)
    end
  }

  if($found)
    res = Array.new
    lineage = $found.parentage.reverse
    lineage.each{ |node|
      res.push(node.content.word)
    }
    res.push($found.content.word)
    res.push($w2)
    
    storeResults(res)
    printResults(res)
    exit
  end

  ii += 1
end

# Handle running out of comparisons
print "You have run out of comparisons.  Please insert another $0.25 for more\n"
